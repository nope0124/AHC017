## やったこと

### 1/28
 - 完全ランダム
 - 工事をできるだけ分けたほうがいいので、工事回数を $ceil(M/D)$ にしておく
 - ローカル実行(0000.txt-0099.txt)スコア合計252,320,706,119、この時点で14B
<br>

 - 全域木を作りながら最大まで工事回数を消費する
 - $10^9$のペナルティを出来る限り回避する
 - ローカル実行(0000.txt-0099.txt)~~スコア合計3,256,265,636~~(バグがありました、何で通ったんだ)、この時点で28B、最終日の上位4割がこの辺になりそう
 - Pythonのrandom.sampleに当たる操作を多用しているから纏めたほうがいいかも
 <br>
 
 ### 1/29
  - ~~ローカル実行(0000.txt-0999.txt)で $10^9$ のペナルティを受けてないことを確認~~バグでした
  - dayによってスコアは独立している→スコアの差分更新できそう
  - 恐らく1dayあたり100msかかるから高速化が鍵？
  - (卒論を修正する→しました)
  - ローカル実行(0000.txt-0099.txt)スコア合計6,003,942,654(一旦)
  - デバッグしました
  - ワーシャルフロイドで辺追加の差分更新だけ $O(N^2)$ でできるようになった
  - ローカル実行(0000.txt-0099.txt)スコア合計3,239,209,934、この時点で23B、ほとんど変化なし
  - リモートスコア1Bを切らないときつそう
  - あと20B-30Bあたりが団子状態になってる
 <br>
 
 ### 1/30
  - Info構造体作成
  - バグ修正
  - ローカル実行(0000.txt-0099.txt)でスコア合計3,245,604,216、変化は誤差、AtCoder上ではスコア改善した
  - 辺削除の高速化恐らく不可能
  - ダイクストラ法をベースとした暫定スコアを定義する
  - ペナルティの判定だけなら $O(MlogN)$でできる
  - ペナルティの削除と差分更新を分ける
  <br>
  
  - ペナルティを回避+工事日の分散の実装
  - ローカル実行(0000.txt-0099.txt)でスコア合計2,575,358,041、この時点で24B
  - 工事日の入れ替えができていないのでその実装、その後暫定スコアを定義する
  - 暫定スコアの実装
  - ローカル実行(0000.txt-0099.txt)でスコア合計2,432,018,714、この時点で22.5B
  - バグ修正
  - 正当性を確かめたい→基本的にスコアが改善、多少悪化するが問題なさそう
  - ローカル実行(0000.txt-0099.txt)でスコア合計2,358,579,789、この時点で23.5B、リモートスコア928M
  
 ### 1/31
  - 評価関数を変更
  - Node0からダイクストラで探索し、一番コストが大きいNodeからも実行して総和を取るようにした
  - ローカル実行(0000.txt-0099.txt)でスコア合計2,381,984,256、この時点で24B、リモートスコア894M
  - スコアは伸びたけどローカルで改善していないのが怖い、1000ケース回して確かめたほうがいいかも
  - あと実行時間を伸ばして改善するかどうか
  - 団子状態の先頭まで来てしまったらしい、ここから劇的な改善がないとどんどん抜かれていきそう
  - とりあえず入れ替えを試してみて様子を伺う
  - 評価関数が軽いのでビームサーチできる？
  - 30秒に伸ばしてローカル実行でスコア合計2,250,828,409
  - 高速化による改善も見込めるが、良くて870Mが限界な気がする
  - 辺のスワップ実装、辺の移動とそんなにスコア変わっていない
  - ローカル実行でスコア合計2,405,908,764

 ### 2/1
  - edge_swap, edge_move, delete_penaltyを修正して拡張しやすくした、その分バグも出たので気をつけたい
  - 評価関数をずっと考えてた
  - ビジュアライザいじってたら天啓が降りてきた
  - 評価関数を削除するedgeの両点からの最短経路の総和に修正
  - ローカル実行(0000.txt-0099.txt)でスコア合計2,350,095,089、この時点で26.5B、リモートスコア779M
  - 20B-23Bの集団から抜き出せて一安心
  - 30秒に伸ばしてローカル実行でスコア合計1,852,683,158
  - 大幅に更新できた、高速化をしたらもっと伸びそう
  - evaluate_scoreを高速化した、ローカル実行でスコア合計2,308,995,971、リモート763M
  
 ### 2/2
  - swapのみローカルスコア2,343,697,624
  - バグ修正、swapのみローカルスコア2,359,448,366
  - swap5%、move95%で実行すると値が悪くなる、ローカル2,319,801,903、リモート770M
  - 微妙な高速化、リモートスコア760M
  - swapってmove2回と同じじゃん、そりゃ悪くなるわ
  - sort無くしたら微改善した、誤差の範囲だと思う、リモート759M
  - 小さいものを優先的に選ぼうとしたら悪化した、ソートの時間が重い、リモート773M
  - 

 ## 次やること
  - とにかく綺麗なコードを心掛けよう
  - とにかく綺麗なコードを心掛けよう
  - とにかく綺麗なコードを心掛けよう
  - ~~LowLinkで差分更新の候補を絞る~~
  - weightが小さい順に選ぶ？
  - 前回のデータと比較してどこで値が減少したか調べる→パラメータチューニングで使う
  - 初期値を変更
